// LilyGO T-SIM A7670G - Version LTE/Cellulaire avec MQTT
// Version 3: MQTT standard (port 1883) avec PubSubClient + TinyGSM

#define TINY_GSM_MODEM_SIM7600  // Le A7670G est compatible avec SIM7600
#define TINY_GSM_RX_BUFFER 1024

#include <TinyGsmClient.h>
#include <PubSubClient.h>

#include "auth.h" // Fichier contenant APN et identifiants MQTT

// ====== CONFIG MODEM A7670G ======
#define MODEM_TX 26
#define MODEM_RX 27
#define MODEM_PWRKEY 4
#define MODEM_DTR 32
#define MODEM_RI 33
#define MODEM_FLIGHT 25
#define MODEM_STATUS 34

#define SD_MISO 2
#define SD_MOSI 15
#define SD_SCLK 14
#define SD_CS 13

// ====== CONFIG MQTT ======
// Note: Utilise MQTT standard (1883) au lieu de WSS (443)
// Car WebSocket n'est pas compatible avec TinyGsmClient sur ESP32
const int MQTT_PORT = 1883;
char MQTT_CLIENT_ID[20];  // Sera généré depuis l'IMEI

char topic_led1_set[50];
char topic_led2_set[50];
char topic_btn1_state[50];
char topic_btn2_state[50];

// --- Configuration des broches (Pins) ---
const int LED1_PIN = 12;   // LED rouge
const int LED2_PIN = 13;   // LED verte
const int BUTTON1_PIN = 0; // Bouton 1
const int BUTTON2_PIN = 35; // Bouton 2

// Serial pour le modem
HardwareSerial SerialAT(1);

// Clients en cascade
TinyGsm modem(SerialAT);
TinyGsmClient gsmClient(modem);
PubSubClient mqttClient(gsmClient);

// État des boutons (pour détecter les changements)
int lastButton1State = HIGH;
int lastButton2State = HIGH;
unsigned long lastButtonCheck = 0;
const unsigned long BUTTON_CHECK_INTERVAL = 100; // ms

// Reconnexion GPRS
unsigned long lastGprsCheck = 0;
const unsigned long GPRS_CHECK_INTERVAL = 30000; // 30 secondes

// ============================================================================
// FONCTIONS MODEM
// ============================================================================

void modemPowerOn() {
  Serial.println("[MODEM] Allumage du modem...");
  pinMode(MODEM_PWRKEY, OUTPUT);
  digitalWrite(MODEM_PWRKEY, HIGH);
  delay(100);
  digitalWrite(MODEM_PWRKEY, LOW);
  delay(1000);
  digitalWrite(MODEM_PWRKEY, HIGH);
  delay(3000);
  Serial.println("[MODEM] ✓ Modem allumé");
}

bool initModem() {
  Serial.println("[MODEM] Initialisation...");

  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);
  delay(3000);

  if (!modem.restart()) {
    Serial.println("[MODEM] ✗ Échec du redémarrage");
    return false;
  }

  String modemInfo = modem.getModemInfo();
  Serial.print("[MODEM] Info: ");
  Serial.println(modemInfo);

  // Récupérer l'IMEI pour générer le Device ID
  String imei = modem.getIMEI();
  Serial.print("[MODEM] IMEI: ");
  Serial.println(imei);

  // Générer Device ID: lte-XXXXXX (6 derniers chiffres de l'IMEI)
  String shortIMEI = imei.substring(imei.length() - 6);
  snprintf(MQTT_CLIENT_ID, sizeof(MQTT_CLIENT_ID), "lte-%s", shortIMEI.c_str());
  Serial.print("[MQTT] Device ID: ");
  Serial.println(MQTT_CLIENT_ID);

  // Générer les topics MQTT
  snprintf(topic_led1_set, sizeof(topic_led1_set), "%s/led/1/set", MQTT_CLIENT_ID);
  snprintf(topic_led2_set, sizeof(topic_led2_set), "%s/led/2/set", MQTT_CLIENT_ID);
  snprintf(topic_btn1_state, sizeof(topic_btn1_state), "%s/button/1/state", MQTT_CLIENT_ID);
  snprintf(topic_btn2_state, sizeof(topic_btn2_state), "%s/button/2/state", MQTT_CLIENT_ID);

  Serial.println("[MODEM] ✓ Initialisé");
  return true;
}

bool connectToNetwork() {
  Serial.println("[NETWORK] Connexion au réseau cellulaire...");

  if (!modem.waitForNetwork(60000L)) {
    Serial.println("[NETWORK] ✗ Échec de connexion au réseau");
    return false;
  }

  String operator_name = modem.getOperator();
  Serial.print("[NETWORK] Opérateur: ");
  Serial.println(operator_name);

  int signalQuality = modem.getSignalQuality();
  Serial.print("[NETWORK] Signal: ");
  Serial.print(signalQuality);
  Serial.println(" dBm");

  Serial.println("[GPRS] Connexion GPRS...");
  if (!modem.gprsConnect(APN, APN_USER, APN_PASS)) {
    Serial.println("[GPRS] ✗ Échec de connexion GPRS");
    return false;
  }

  if (!modem.isGprsConnected()) {
    Serial.println("[GPRS] ✗ GPRS non connecté");
    return false;
  }

  IPAddress ip = modem.localIP();
  Serial.print("[GPRS] IP: ");
  Serial.println(ip);
  Serial.println("[GPRS] ✓ Connecté");

  return true;
}

// ============================================================================
// CALLBACK MQTT
// ============================================================================

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String message;
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }

  Serial.print("[MQTT] ← ");
  Serial.print(topic);
  Serial.print(" = ");
  Serial.println(message);

  // Contrôle des LEDs
  if (strcmp(topic, topic_led1_set) == 0) {
    if (message == "ON") {
      digitalWrite(LED1_PIN, HIGH);
      Serial.println("[LED1] Allumée (ROUGE)");
    } else if (message == "OFF") {
      digitalWrite(LED1_PIN, LOW);
      Serial.println("[LED1] Éteinte");
    }
  }
  else if (strcmp(topic, topic_led2_set) == 0) {
    if (message == "ON") {
      digitalWrite(LED2_PIN, HIGH);
      Serial.println("[LED2] Allumée (VERTE)");
    } else if (message == "OFF") {
      digitalWrite(LED2_PIN, LOW);
      Serial.println("[LED2] Éteinte");
    }
  }
}

// ============================================================================
// CONNEXION MQTT
// ============================================================================

bool connectMQTT() {
  Serial.print("[MQTT] Connexion au broker: ");
  Serial.print(MQTT_BROKER);
  Serial.print(":");
  Serial.println(MQTT_PORT);

  // Configuration MQTT
  mqttClient.setServer(MQTT_BROKER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);
  mqttClient.setKeepAlive(60);
  mqttClient.setSocketTimeout(30);

  // Tentative de connexion
  if (mqttClient.connect(MQTT_CLIENT_ID, MQTT_USER, MQTT_PASS)) {
    Serial.println("[MQTT] ✓ Connecté");

    // Souscrire aux topics de contrôle des LEDs
    mqttClient.subscribe(topic_led1_set);
    mqttClient.subscribe(topic_led2_set);

    Serial.println("[MQTT] Souscriptions:");
    Serial.print("  - ");
    Serial.println(topic_led1_set);
    Serial.print("  - ");
    Serial.println(topic_led2_set);

    return true;
  } else {
    Serial.print("[MQTT] ✗ Échec, code: ");
    Serial.println(mqttClient.state());
    return false;
  }
}

// ============================================================================
// GESTION DES BOUTONS
// ============================================================================

void checkButtons() {
  unsigned long now = millis();

  if (now - lastButtonCheck < BUTTON_CHECK_INTERVAL) {
    return;
  }
  lastButtonCheck = now;

  if (!mqttClient.connected()) return;

  // Vérifier le bouton 1
  int button1State = digitalRead(BUTTON1_PIN);
  if (button1State != lastButton1State) {
    lastButton1State = button1State;

    const char* state = (button1State == LOW) ? "PRESSED" : "RELEASED";
    if (mqttClient.publish(topic_btn1_state, state)) {
      Serial.print("[BTN1] → ");
      Serial.println(state);
    }
  }

  // Vérifier le bouton 2
  int button2State = digitalRead(BUTTON2_PIN);
  if (button2State != lastButton2State) {
    lastButton2State = button2State;

    const char* state = (button2State == LOW) ? "PRESSED" : "RELEASED";
    if (mqttClient.publish(topic_btn2_state, state)) {
      Serial.print("[BTN2] → ");
      Serial.println(state);
    }
  }
}

// ============================================================================
// SETUP
// ============================================================================

void setup() {
  Serial.begin(115200);
  delay(2000);

  Serial.println();
  Serial.println("=== LilyGo T-SIM A7670G - MQTT via LTE ===");
  Serial.println("Version: MQTT standard (port 1883)");
  Serial.println();

  // Configuration des pins
  pinMode(LED1_PIN, OUTPUT);
  pinMode(LED2_PIN, OUTPUT);
  pinMode(BUTTON1_PIN, INPUT_PULLUP);
  pinMode(BUTTON2_PIN, INPUT_PULLUP);

  digitalWrite(LED1_PIN, LOW);
  digitalWrite(LED2_PIN, LOW);

  // Démarrage du modem
  modemPowerOn();

  if (!initModem()) {
    Serial.println("[ERREUR] Impossible d'initialiser le modem");
    Serial.println("Redémarrez l'appareil");
    while (true) {
      digitalWrite(LED1_PIN, !digitalRead(LED1_PIN));
      delay(200);
    }
  }

  if (!connectToNetwork()) {
    Serial.println("[ERREUR] Impossible de se connecter au réseau");
    Serial.println("Vérifiez votre carte SIM et l'APN");
    while (true) {
      digitalWrite(LED1_PIN, !digitalRead(LED1_PIN));
      delay(500);
    }
  }

  if (!connectMQTT()) {
    Serial.println("[ERREUR] Impossible de se connecter au broker MQTT");
    Serial.println("Vérifiez les identifiants dans auth.h");
    while (true) {
      digitalWrite(LED1_PIN, !digitalRead(LED1_PIN));
      delay(1000);
    }
  }

  Serial.println();
  Serial.println("=== Système prêt ===");
  Serial.println();

  // Clignoter les LEDs pour indiquer que tout est OK
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED1_PIN, HIGH);
    digitalWrite(LED2_PIN, HIGH);
    delay(200);
    digitalWrite(LED1_PIN, LOW);
    digitalWrite(LED2_PIN, LOW);
    delay(200);
  }
}

// ============================================================================
// LOOP
// ============================================================================

void loop() {
  unsigned long now = millis();

  // Vérifier la connexion GPRS périodiquement
  if (now - lastGprsCheck > GPRS_CHECK_INTERVAL) {
    lastGprsCheck = now;

    if (!modem.isGprsConnected()) {
      Serial.println("[GPRS] Connexion perdue, reconnexion...");
      if (connectToNetwork()) {
        if (connectMQTT()) {
          Serial.println("[GPRS] ✓ Reconnecté");
        }
      }
    }
  }

  // Maintenir la connexion MQTT
  if (!mqttClient.connected()) {
    Serial.println("[MQTT] Connexion perdue, reconnexion...");
    if (connectMQTT()) {
      Serial.println("[MQTT] ✓ Reconnecté");
    } else {
      delay(5000);
      return;
    }
  }

  // Traiter les messages MQTT
  mqttClient.loop();

  // Vérifier les boutons
  checkButtons();

  // Petit délai pour ne pas surcharger
  delay(10);
}
